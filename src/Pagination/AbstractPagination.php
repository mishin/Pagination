<?php/* * This file is part of the UCSDMath package. * * (c) UCSD Mathematics | Math Computing Support <mathhelp@math.ucsd.edu> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */namespace UCSDMath\Pagination;use Carbon\Carbon;use UCSDMath\Functions\ServiceFunctions;use UCSDMath\Pagination\PaginatorInterface;use UCSDMath\Functions\ServiceFunctionsInterface;use UCSDMath\Pagination\Exception\CallbackNotFoundException;use UCSDMath\Pagination\Exception\InvalidPageNumberException;/** * AbstractPagination provides an abstract base class implementation of {@link PaginationInterface}. * Primarily, this services the fundamental implementations for all Pagination classes. * * Paginator provides a process of dividing (content) into discrete pages that are * acceptable or desirable to the user. * * Important considerations in this class are: *    - SEO Friendly URLS *    - Dynamic search results (sticky or hold state) *    - Standard scheme for Front Controllers *    - Provide options for template generator (e.g., Twig, Plates, Smarty) *    - Provided via data structure * * Technically, for pagination to work, all is needed is the page number of the current set. * *    $page = filter_input(INPUT_GET, 'page', FILTER_VALIDATE_INT); *    $items_per_page = 4; * * *    $total_items = "SELECT COUNT(*) FROM personnel; *    $row_count   = "SELECT COUNT(*) FROM personnel where group = 'faculty'; * *    if ($total_items === 0) { print 'No records exist in the database.';} *    if ($row_count === 0)   { print 'No records found in database with you exact match.';} * * *    $page_count = (int) ceil($row_count / $items_per_page); * *    // range error; we could just set page = 1 *    if ($page > $page_count) {$page = 1;} * * *    $offset = ($page - 1) * $items_per_page; *    $sql = "SELECT * FROM personnel where (group = 'faculty') (ORDER BY lastname, firstname) LIMIT " . $offset . "," . $items_per_page; * *    Result: SELECT * FROM personnel LIMIT 4,4 * * Examples of useful url patterns: *    - /sso/1/personnel/(:page)/(:rows)/(:sort)/ *    - /sso/1/personnel/quick-search/(:page)/(:rows)/(:search)/(:sort)/ *    - /sso/1/personnel/edit-search/page-(:page)/show-(:rows)/(:search)/(:sort)/ *    - /sso/1/personnel/edit-record/page-(:page)/ * * Method list: * * @see (+) __construct(); * @see (+) __destruct(); * @see (+) __toString(); * @see (+) getNextUrl(); * @see (+) getPrevUrl(); * @see (+) getNextPage(); * @see (+) getNumPages(); * @see (+) getPrevPage(); * @see (+) getPageCount(); * @see (-) setPageCount(); * @see (-) getPageOffset(); * @see (+) getTotalItems(); * @see (+) getUrlPattern(); * @see (+) renderAsArray(); * @see (-) setPageOffset(); * @see (+) getItemsPerPage(); * @see (+) getMaxPagesToShow(); * @see (+) renderLargePaging(); * @see (+) getPageUrl($pageNum); * @see (-) createPageEllipsis(); * @see (+) renderCompactPaging(); * @see (+) getCurrentPageNumber(); * @see (+) getLimitPerPageOffset(); * @see (+) getCurrentPageLastItem(); * @see (-) isValidPageNumber($page); * @see (+) getCurrentPageFirstItem(); * @see (+) renderAsJson($options = 0); * @see (+) setTotalItems($totalItems); * @see (+) setUrlPattern($urlPattern); * @see (+) setItemsPerPage($itemsPerPage); * @see (+) setMaxPagesToShow($maxPagesToShow); * @see (+) setRenderAsJson(\Closure $renderAsJson); * @see (-) createPage($pageNum, $isCurrent = false); * @see (+) setCurrentPageNumber($currentPageNumber = null); * @see (+) setLimitPerPageOffset(\Closure $limitPerPageOffset); * @see (+) recalculate(array $settings = null, array $options = array()); * * @author Daryl Eisner <deisner@ucsd.edu> */abstract class AbstractPagination implements PaginationInterface, ServiceFunctionsInterface{    /**     * Constants.     */    const VERSION = '1.0.5';    /**     * Properties.     *     * @var    integer             $pageCount            A number of pages to render (e.g., a calculation) (e.g., 780)     * @var    integer             $totalItems           A total number of found records in table (e.g., 8500)     * @var    integer             $pageOffset           A interger used to define our SQL OFFSET (e.g., 60)     * @var    string              $urlPattern           A default url with placeholders (e.g., '/sso/1/news/(:page)/(:rows)/(:search)/')     * @var    string              $sortPattern          A default sort url pattern (:sort) (e.g., 'group-lastname-firstname')     * @var    integer             $itemsPerPage         A display setting showing a number of records per page (e.g., 15)     * @var    integer             $maxPagesToShow       A maximum number of pages for the <select> menu (e.g., 10)     * @var    string              $searchPattern        A search pattern used in the url (:search) (e.g., 'dillon-or-drop')     * @var    integer             $currentPageNumber    A current page number (e.g., 8)     * @var    \Closure            $renderAsJson         A closure callback for encoding json data     * @var    \Closure            $limitPerPageOffset   A closure callback for the limit offset     * @var    boolean             $isUrlPatternUsed     A boolean option that enables the pattern type     * @var    boolean             $isSortPatternUsed    A boolean option that enables the pattern type     * @var    boolean             $isItemsPerPageUsed   A boolean option that enables the pattern type     * @var    boolean             $isSearchPatternUsed  A boolean option that enables the pattern type     * @var    array               $storageRegister      A set of validation stored data elements     * @static PaginationInterface $instance             A PaginationInterface instance     * @static integer             $objectCount          A PaginationInterface instance count     */    protected $pageCount = null;    protected $totalItems = null;    protected $pageOffset = null;    protected $urlPattern = null;    protected $sortPattern = null;    protected $itemsPerPage = null;    protected $maxPagesToShow = 10;    protected $renderAsJson = null;    protected $searchPattern = null;    protected $currentPageNumber = null;    protected $limitPerPageOffset = null;    protected $isUrlPatternUsed = false;    protected $isSortPatternUsed = false;    protected $isItemsPerPageUsed = false;    protected $isSearchPatternUsed = false;    protected $storageRegister = array();    protected static $instance = null;    protected static $objectCount = 0;    /**     * Constructor.     *     * @param array $settings  A list of page settings.     *     * @throws \LogicException on incorrect settings     *     * @api     */    public function __construct(array $settings = null, array $options = array())    {        /**         * Adding array_key_exists() to handle the null cases while keeping the speed of isset()         * Benchmark: isset() = 4.7ms, array_key_exists() = 308ms.         * Array values of null are rare.         */        /* load defined integers */        isset($settings['totalItems']) || array_key_exists('totalItems', $settings)            ? $this->setProperty('totalItems', (int) $settings['totalItems'])            : null ;        isset($settings['itemsPerPage']) || array_key_exists('itemsPerPage', $settings)            ? $this->setProperty('itemsPerPage', (int) $settings['itemsPerPage'])            : null ;        isset($settings['currentPageNumber']) || array_key_exists('currentPageNumber', $settings)            ? $this->setProperty('currentPageNumber', (int) $settings['currentPageNumber'])            : null ;        isset($settings['maxPagesToShow']) || array_key_exists('maxPagesToShow', $settings)            ? $this->setProperty('maxPagesToShow', (int) $settings['maxPagesToShow'])            : null ;        /* load defined strings */        isset($settings['urlPattern']) || array_key_exists('urlPattern', $settings)            ? $this->setProperty('urlPattern', (string) $settings['urlPattern'])            : null ;        isset($settings['searchPattern']) || array_key_exists('searchPattern', $settings)            ? $this->setProperty('searchPattern', (string) $settings['searchPattern'])            : null ;        isset($settings['sortPattern']) || array_key_exists('sortPattern', $settings)            ? $this->setProperty('sortPattern', (string) $settings['sortPattern'])            : null ;        /* load defined Boolean */        isset($settings['isSearchPatternUsed']) || array_key_exists('isSearchPatternUsed', $settings)            ? $this->setProperty('isSearchPatternUsed', (bool) $settings['isSearchPatternUsed'])            : null ;        isset($settings['isSortPatternUsed']) || array_key_exists('isSortPatternUsed', $settings)            ? $this->setProperty('isSortPatternUsed', (bool) $settings['isSortPatternUsed'])            : null ;        isset($settings['isUrlPatternUsed']) || array_key_exists('isUrlPatternUsed', $settings)            ? $this->setProperty('isUrlPatternUsed', (bool) $settings['isUrlPatternUsed'])            : null ;        isset($settings['isItemsPerPageUsed']) || array_key_exists('isItemsPerPageUsed', $settings)            ? $this->setProperty('isItemsPerPageUsed', (bool) $settings['isItemsPerPageUsed'])            : null ;        if ($this->maxPagesToShow < 3) {            throw new \LogicException('Number of neighboring pages must be at least 3');        }        if ($this->itemsPerPage < 1) {            throw new \LogicException('Items per page must be at least 1');        }        if ($this->currentPageNumber < static::DEFAULT_PAGE) {            $this->currentPageNumber = static::DEFAULT_PAGE;        }        /** callback to {$limitPerPageOffset} for page override */        $this->setLimitPerPageOffset(function ($currentPageNumber) use (&$settings) {            $offset = $this->setPageOffset()->getPageOffset() + ($currentPageNumber * $this->itemsPerPage);            return [$offset, $this->itemsPerPage];        });        /** callback to {$renderAsJson} for json encoded data structure */        $this->setRenderAsJson(function ($options) use (&$settings) {            $this->setProperty('totalItems', (int) $settings['totalItems']);            $this->setProperty('itemsPerPage', (int) $settings['itemsPerPage']);            $this->setPageCount();            $this->setCurrentPageNumber();            return json_encode($this->renderAsArray(), $options);        });        foreach ($options as $key => $value) {            $this->{$key} = $value;        }        $this->setPageCount();        $this->setCurrentPageNumber();        static::$instance = $this;        static::$objectCount++;    }    /**     * Destructor.     */    public function __destruct()    {        static::$objectCount--;    }    /**     * {@inheritdoc}     */    public function setLimitPerPageOffset(\Closure $limitPerPageOffset)    {        $this->setProperty('limitPerPageOffset', $limitPerPageOffset);        return $this;    }    /**     * {@inheritdoc}     */    public function setRenderAsJson(\Closure $renderAsJson)    {        $this->setProperty('renderAsJson', $renderAsJson);        return $this;    }    /**     * {@inheritdoc}     */    public function getLimitPerPageOffset(\Closure $overridePerPageOffset = null, $newPage = null)    {        $offset = $this->setPageOffset()->getPageOffset();        return ($overridePerPageOffset instanceof \Closure)            ? $overridePerPageOffset($newPage)            : [$offset, $this->itemsPerPage];    }    /**     * Forward to any callable, including anonymous functions     * (or any instances of \Closure).     *     * @param string $callback    A named callable to be called.     * @param mixed  $parameters  A parameter set to be passed to the callback (as an indexed array).     *     * @return mixed  the return value of the callback, or false on error.     *     * @api     */    public function __call($callback, $parameters)    {        return call_user_func_array($this->$callback, $parameters);    }    /**     * Set the page offset.     *     * @return PaginationInterface     *     * @api     */    protected function setPageOffset()    {        ($this->currentPageNumber > $this->pageCount)            ? $this->setProperty('currentPageNumber', static::DEFAULT_PAGE)            : null;        ($this->itemsPerPage < 1)            ? $this->setProperty('itemsPerPage', static::DEFAULT_PAGE)            : null;        $this->setProperty(            'pageOffset',            abs(intval($this->currentPageNumber * $this->itemsPerPage - $this->itemsPerPage))        );        return $this;    }    /**     * Get the page offset.     *     * @return integer     *     * @api     */    protected function getPageOffset()    {        return $this->getProperty('pageOffset');    }    /**     * Calculate the number of pages.     *     * @return bool     */    protected function setPageCount()    {        ((int) $this->itemsPerPage === 0)            ? $this->setProperty('pageCount', 0)            : $this->setProperty('pageCount', (int) ceil((int) $this->totalItems / (int) $this->itemsPerPage));        return $this;    }    /**     * {@inheritdoc}     */    public function recalculate(array $settings = null, array $options = array())    {        if (!($this->limitPerPageOffset instanceof \Closure)) {            throw new CallbackNotFoundException(                'LimitPerPageOffset callback not found, set it using Paginator::setLimitPerPageOffset()');        }        /* load defined integers */        isset($settings['totalItems']) || array_key_exists('totalItems', $settings)            ? $this->setProperty('totalItems', (int) $settings['totalItems'])            : null ;        isset($settings['itemsPerPage']) || array_key_exists('itemsPerPage', $settings)            ? $this->setProperty('itemsPerPage', (int) $settings['itemsPerPage'])            : null ;        isset($settings['currentPageNumber']) || array_key_exists('currentPageNumber', $settings)            ? $this->setProperty('currentPageNumber', (int) $settings['currentPageNumber'])            : null ;        isset($settings['maxPagesToShow']) || array_key_exists('maxPagesToShow', $settings)            ? $this->setProperty('maxPagesToShow', (int) $settings['maxPagesToShow'])            : null ;        /* load defined strings */        isset($settings['urlPattern']) || array_key_exists('urlPattern', $settings)            ? $this->setProperty('urlPattern', (string) $settings['urlPattern'])            : null ;        isset($settings['searchPattern']) || array_key_exists('searchPattern', $settings)            ? $this->setProperty('searchPattern', (string) $settings['searchPattern'])            : null ;        isset($settings['sortPattern']) || array_key_exists('sortPattern', $settings)            ? $this->setProperty('sortPattern', (string) $settings['sortPattern'])            : null ;        /* load defined Boolean */        isset($settings['isSearchPatternUsed']) || array_key_exists('isSearchPatternUsed', $settings)            ? $this->setProperty('isSearchPatternUsed', (bool) $settings['isSearchPatternUsed'])            : null ;        isset($settings['isSortPatternUsed']) || array_key_exists('isSortPatternUsed', $settings)            ? $this->setProperty('isSortPatternUsed', (bool) $settings['isSortPatternUsed'])            : null ;        isset($settings['isUrlPatternUsed']) || array_key_exists('isUrlPatternUsed', $settings)            ? $this->setProperty('isUrlPatternUsed', (bool) $settings['isUrlPatternUsed'])            : null ;        isset($settings['isItemsPerPageUsed']) || array_key_exists('isItemsPerPageUsed', $settings)            ? $this->setProperty('isItemsPerPageUsed', (bool) $settings['isItemsPerPageUsed'])            : null ;        if ($this->maxPagesToShow <= 3) {            throw new \LogicException('Number of neighboring pages must be at least 3');        }        if ($this->itemsPerPage <= 0) {            throw new \LogicException('Items per page must be at least 1');        }        if ($this->currentPageNumber < static::DEFAULT_PAGE) {            $this->currentPageNumber = static::DEFAULT_PAGE;        }        foreach ($options as $key => $value) {            $this->{$key} = $value;        }        $this->setPageCount();        $this->setCurrentPageNumber();        return $this;    }    /**     * {@inheritdoc}     */    public function getPageCount()    {        return (int) $this->getProperty('pageCount');    }    /**     * Determine if the given value is a valid page number.     *     * @param  integer $page  A page number.     *     * @return Boolean     */    protected function isValidPageNumber($page)    {        return $page >= 1 && filter_var($page, FILTER_VALIDATE_INT) !== false;    }    /**     * {@inheritdoc}     */    public function setMaxPagesToShow($maxPagesToShow)    {        if ((int) $maxPagesToShow < 3) {            throw new \InvalidArgumentException('maxPagesToShow cannot be less than 3.');        }        $this->setProperty('maxPagesToShow', (int) $maxPagesToShow);        return $this;    }    /**     * {@inheritdoc}     */    public function getMaxPagesToShow()    {        return $this->getProperty('maxPagesToShow');    }    /**     * {@inheritdoc}     */    public function setCurrentPageNumber($currentPageNumber = null)    {        $currentPageNumber === null            ? null            : $this->setProperty('currentPageNumber', (int) $currentPageNumber);        $this->currentPageNumber > $this->pageCount            ? $this->setProperty('currentPageNumber', static::DEFAULT_PAGE)            : null;        return $this;    }    /**     * {@inheritdoc}     */    public function getCurrentPageNumber()    {        return $this->currentPageNumber > $this->pageCount            ? static::DEFAULT_PAGE            : (int) $this->getProperty('currentPageNumber');    }    /**     * {@inheritdoc}     */    public function setItemsPerPage($itemsPerPage)    {        if (!is_int($itemsPerPage)) {            throw new \InvalidArgumentException('$itemsPerPage must be passed as a integer');        }        $this->setProperty('itemsPerPage', (int) $itemsPerPage);        $this->updateNumPages();        return $this;    }    /**     * {@inheritdoc}     */    public function getItemsPerPage()    {        return (int) $this->getProperty('itemsPerPage');    }    /**     * {@inheritdoc}     */    public function setTotalItems($totalItems)    {        if (!is_int($totalItems)) {            throw new \InvalidArgumentException('$totalItems must be passed as a integer');        }        $this->setProperty('totalItems', (int) $totalItems);        $this->updateNumPages();        return $this;    }    /**     * {@inheritdoc}     */    public function getTotalItems()    {        return (int) $this->getProperty('totalItems');    }    /**     * {@inheritdoc}     */    public function getNumPages()    {        return (int) $this->getProperty('pageCount');    }    /**     * {@inheritdoc}     */    public function setUrlPattern($urlPattern)    {        if (isString($urlPattern)) {            throw new \InvalidArgumentException('$urlPattern must be passed as a string');        }        $this->setProperty('urlPattern', (string) $urlPattern);        return $this;    }    /**     * {@inheritdoc}     */    public function getUrlPattern()    {        return $this->getProperty('urlPattern');    }    /**     * {@inheritdoc}     */    public function getPageUrl($pageNum)    {        if (!is_int($pageNum)) {            throw new \InvalidArgumentException('$pageNum must be passed as a integer');        }        $url = str_replace(self::PAGE_PLACEHOLDER, (int) $pageNum, $this->urlPattern);        $url = $this->isItemsPerPageUsed            ? str_replace(self::ROWS_PLACEHOLDER, (int) $this->itemsPerPage, $url)            : str_replace(self::ROWS_PLACEHOLDER.'/', null, $url);        $url = $this->isSortPatternUsed            ? str_replace(self::SORT_PLACEHOLDER, (string) $this->sortPattern, $url)            : str_replace(self::SORT_PLACEHOLDER.'/', null, $url);        $url = $this->isSearchPatternUsed            ? str_replace(self::SEARCH_PLACEHOLDER, (string) $this->searchPattern, $url)            : str_replace(self::SEARCH_PLACEHOLDER.'/', null, $url);        return $url;    }    /**     * {@inheritdoc}     */    public function getNextPage()    {        return (int) $this->currentPageNumber < (int) $this->pageCount            ? (int) $this->currentPageNumber + 1            : null;    }    /**     * {@inheritdoc}     */    public function getPrevPage()    {        return (int) $this->currentPageNumber > 1            ? (int) $this->currentPageNumber - 1            : null;    }    /**     * {@inheritdoc}     */    public function getNextUrl()    {        return $this->getNextPage()            ? $this->getPageUrl($this->getNextPage())            : null;    }    /**     * {@inheritdoc}     */    public function getPrevUrl()    {        return $this->getPrevPage()            ? $this->getPageUrl($this->getPrevPage())            : null;    }    /**     * {@inheritdoc}     */    public function renderAsArray()    {        $pages = array();        if ((int) $this->pageCount <= 1) {            return array();        }        if ((int) $this->pageCount <= (int) $this->maxPagesToShow) {            for ($i = 1; $i <= (int) $this->pageCount; $i++) {                $pages[] = $this->createPage($i, $i === (int) $this->currentPageNumber);            }        } else {            /** Determine the sliding range, centered around the current page */            $numAdjacents = (int) floor(((int) $this->maxPagesToShow - 3) / 2);            if ((int) $this->currentPageNumber + $numAdjacents > (int) $this->pageCount) {                $slidingStart = (int) $this->pageCount - (int) $this->maxPagesToShow + 2;            } else {                $slidingStart = (int) $this->currentPageNumber - $numAdjacents;            }            if ($slidingStart < 2) $slidingStart = 2;            $slidingEnd = $slidingStart + (int) $this->maxPagesToShow - 3;            if ($slidingEnd >= (int) $this->pageCount) {                $slidingEnd = (int) $this->pageCount - 1;            }            /** Build the list of pages */            $pages[] = $this->createPage(1, (int) $this->currentPageNumber === 1);            if ($slidingStart > 2) {                $pages[] = $this->createPageEllipsis();            }            for ($i = $slidingStart; $i <= $slidingEnd; $i++) {                $pages[] = $this->createPage($i, $i === (int) $this->currentPageNumber);            }            if ($slidingEnd < (int) $this->pageCount - 1) {                $pages[] = $this->createPageEllipsis();            }            $pages[] = $this->createPage((int) $this->pageCount, (int) $this->currentPageNumber === (int) $this->pageCount);        }        return $pages;    }    /**     * Create a page data structure.     *     * @param  integer $pageNum    A page number for data structure     * @param  boolean $isCurrent  A boolean if is the current page     *     * @throws \InvalidArgumentException     *     * @return array     */    protected function createPage($pageNum, $isCurrent = false)    {        if (!is_bool($isCurrent)) {            throw new \InvalidArgumentException('$isCurrent must be passed as a boolean');        }        if (!is_int($pageNum)) {            throw new \InvalidArgumentException('$pageNum must be passed as a integer');        }        return array(            'num' => (int) $pageNum,            'url' => $this->getPageUrl($pageNum),            'isCurrent' => $isCurrent,        );    }    /**     * Create ellipses as a pagination indicator.     *     * @return array     */    protected function createPageEllipsis()    {        return array(            'num' => static::NAVIGATION_ELLIPSES,            'url' => null,            'isCurrent' => false,        );    }    /**     * {@inheritdoc}     */    public function renderCompactPaging()    {        $html = '';        if ((int) $this->getNumPages() > 1) {            if ($this->isItemsPerPageUsed) {                $html .= '<div class="" style="width:345px;float:left;margin:0;padding:0;">'."\n";            } else {                $html .= '<div class="" style="width:230px;float:left;margin:0;padding:0;">'."\n";            }            if ($this->getPrevUrl()) {                $html .= '<span style="float:left;">'."\n";                $html .= '    <a href="' . str_replace(['"'], ['%22'], $this->getPrevUrl()) . '" class="btn btn-default" type="button">'.static::NAVIGATION_ARROW_PREV.'</a>'."\n";                $html .= '</span>'."\n\n";            } else {                $html .= '<span style="float:left;">'."\n";                $html .= '    <a href="' . '#' . '" class="btn btn-default" type="button" style="pointer-events: none;">'.static::NAVIGATION_ARROW_PREV.'</a>'."\n";                $html .= '</span>'."\n\n";            }            $html .= '<select class="form-control paginator-control" style="float:left;width:90px; cursor: pointer; -webkit-appearance: none; -moz-appearance: none; appearance: none;">'."\n";            foreach ($this->renderAsArray() as $page) {                if ($page['url']) {                    $html .= '    <option value="'. str_replace(['"'], ['%22'], $page['url']) .'"';                    $html .= $page['isCurrent'] ? ' selected="selected">' : '>' ;                    $html .= 'Page '. $page['num'] . '</option>'."\n";                } else {                    $html .= '    <option disabled>'. $page['num'] . '</option>' ."\n";                }            }            $html .= '</select>'."\n\n";            if ($this->getNextUrl()) {                $html .= '<span style="float:left;">'."\n";                $html .= '    <a href="' . str_replace(['"'], ['%22'], $this->getNextUrl()) . '" class="btn btn-default" type="button">'.static::NAVIGATION_ARROW_NEXT.'</a>'."\n";                $html .= '</span>'."\n";            } else {                $html .= '<span style="float:left;">'."\n";                $html .= '    <a href="' . '#' . '" class="btn btn-default" type="button" style="pointer-events: none;">'.static::NAVIGATION_ARROW_NEXT.'</a>'."\n";                $html .= '</span>'."\n";            }            if ($this->isItemsPerPageUsed) {                $html .= '<button class="button secondary" id="button-pagination-show" name="button" type="button" tabindex="4" value="pagination-show" style="float:left;margin:4px 4px 4px 8px;">Show</button>'."\n";                $html .= sprintf('<input class="input-paginator-items-per-page" id="paginator-items-per-page" name="paginator-items-per-page" type="text" maxlength="50" placeholder="##" title="Show records per page" tabindex="1" style="border-radius:4px;border:1px solid #1A87B9;width: 40px;text-align:center;padding:3px;margin:2px 2px 2px 1px;font-size:16px;float:left;" value="%s">', $this->itemsPerPage);            }            $html .= '</div>';        } else {            if ($this->isItemsPerPageUsed) {                $html .= '<div class="" style="width:345px;float:left;margin:0;padding:0;">'."\n";            } else {                $html .= '<div class="" style="width:230px;float:left;margin:0;padding:0;">'."\n";            }            $html .= '<span style="float:left;">'."\n";            $html .= '    <a href="' . '#' . '" class="btn btn-default" type="button" style="pointer-events: none;">'.static::NAVIGATION_ARROW_PREV.'</a>'."\n";            $html .= '</span>'."\n\n";            $html .= '<select class="form-control paginator-control" style="float:left;width:90px; cursor: pointer; -webkit-appearance: none; -moz-appearance: none; appearance: none;">'."\n";            $html .= '    <option value="'. str_replace(['"'], ['%22'], $this->getPageUrl(1)) .' selected="selected">Page 1</option>'."\n";            $html .= '</select>'."\n\n";            $html .= '<span style="float:left;">'."\n";            $html .= '    <a href="' . '#' . '" class="btn btn-default" type="button" style="pointer-events: none;">'.static::NAVIGATION_ARROW_NEXT.'</a>'."\n";            $html .= '</span>'."\n";            if ($this->isItemsPerPageUsed) {                $html .= '<button class="button secondary" id="button-pagination-show" name="button" type="button" tabindex="4" value="pagination-show" style="float:left;margin:4px 4px 4px 8px;">Show</button>'."\n";                $html .= sprintf('<input class="input-paginator-items-per-page" id="paginator-items-per-page" name="paginator-items-per-page" type="text" maxlength="50" placeholder="##" title="Show records per page" tabindex="1" style="border-radius:4px;border:1px solid #1A87B9;width: 40px;text-align:center;padding:3px;margin:2px 2px 2px 1px;font-size:16px;float:left;" value="%s">', $this->itemsPerPage);            }            $html .= '</div>';        }        // add comment that jQuery pagination in /sso/1/assets/js/vendor/ucsdmath-functions.min.js        return $html;    }    /**     * {@inheritdoc}     */    public function renderLargePaging()    {        if ((int) $this->pageCount <= 1) {            return '';        }        $html = '<ul class="pagination">'."\n";        if ($this->getPrevUrl()) {            $html .= '<li><a href="'.$this->getPrevUrl().'">'.static::NAVIGATION_ARROW_PREV.'</a></li>'."\n";        }        foreach ($this->renderAsArray() as $page) {            if ($page['url']) {                $html .= '<li'.($page['isCurrent'] ? ' class="active"' : '').'><a href="'.$page['url'].'">'.$page['num'].'</a></li>'."\n";            } else {                $html .= '<li class="disabled"><span>'.$page['num'].'</span></li>'."\n";            }        }        if ($this->getNextUrl()) {            $html .= '<li><a href="'.$this->getNextUrl().'">'.static::NAVIGATION_ARROW_NEXT.'</a></li>'."\n";        }        $html .= '</ul>'."\n";        return $html;    }    /**     * {@inheritdoc}     */    public function __toString()    {        return $this->renderCompactPaging();    }    /**     * {@inheritdoc}     */    public function getCurrentPageFirstItem()    {        $first = ((int) $this->currentPageNumber - 1) * (int) $this->itemsPerPage + 1;        return $first > (int) $this->totalItems            ? null            : $first;    }    /**     * {@inheritdoc}     */    public function getCurrentPageLastItem()    {        $first = $this->getCurrentPageFirstItem();        if ($first === null) {            return null;        }        $last = $first + (int) $this->itemsPerPage - 1;        return ($last > (int) $this->totalItems)            ? (int) $this->totalItems            : $last;    }    /**     * Method implementations inserted.     *     * The notation below illustrates visibility: (+) @api, (-) protected or private.     *     * @see (+) all();     * @see (+) init();     * @see (+) get($key);     * @see (+) has($key);     * @see (+) version();     * @see (+) getClassName();     * @see (+) getConst($key);     * @see (+) set($key, $value);     * @see (+) isString($string);     * @see (+) getInstanceCount();     * @see (+) getClassInterfaces();     * @see (+) __call($callback, $parameters);     * @see (+) getProperty($name, $key = null);     * @see (-) doesFunctionExist($functionName);     * @see (+) isStringKey($string, array $keys);     * @see (-) throwExceptionError(array $error);     * @see (+) setProperty($name, $value, $key = null);     * @see (-) throwInvalidArgumentExceptionError(array $error);     */    use ServiceFunctions;}